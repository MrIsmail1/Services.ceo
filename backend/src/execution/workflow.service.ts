import { Injectable, NotFoundException } from '@nestjs/common';
import { AiService } from '../ai/ai.service';
import { 
  WorkflowExecution, 
  WorkflowStep, 
  WorkflowResponse, 
  WorkflowStepResult 
} from './types/workflow.types';
import { ConfigurationService } from '../configuration/configuration.service';

@Injectable()
export class WorkflowService {
  constructor(
    private readonly ai: AiService,
    private readonly configurationService: ConfigurationService
  ) {}

  async executeWorkflow(
    serviceId: string,
    serviceName: string,
    input: any,
    systemPrompt: string,
    userPrompt: string,
    provider?: 'lama' | 'mistral'
  ): Promise<WorkflowResponse> {
    const workflowId = `workflow_${Date.now()}`;
    
    // On commence avec une seule √©tape : validation
    const steps: WorkflowStep[] = [
      {
        id: 'input-validation',
        name: 'Validation des entr√©es',
        description: 'V√©rification et collecte des informations n√©cessaires',
        status: 'pending'
      }
    ];

    const workflow: WorkflowExecution = {
      id: workflowId,
      steps,
      currentStepIndex: 0,
      status: 'running',
      input
    };

    try {
      // √âtape 1: Validation stricte bas√©e sur inputSchema
      const validationResult = await this.executeStep(workflow, 0, async () => {
        // Charger la config du service
        const { data: config } = await this.configurationService.getByServiceId(serviceId);
        if (!config) throw new NotFoundException('Configuration du service introuvable');
        const inputSchema = config.inputSchema;
        const requiredFields: string[] = inputSchema.required || [];
        const properties = inputSchema.properties || {};

        // Champs manquants
        const missingFields = requiredFields.filter(
          (key) => input[key] === undefined || input[key] === null || input[key] === ''
        );

        if (missingFields.length > 0) {
          // G√©n√©rer les questions √† partir de la config
          const questions = missingFields.map((key) => {
            const prop = properties[key] || {};
            const label = prop.title || prop.label || key;
            const desc = prop.description ? ` (${prop.description})` : '';
            return `Merci de renseigner : ${label}${desc}`;
          });

          const interactiveMessage = `üîç **Validation des entr√©es**\n\nIl manque des informations pour ex√©cuter la t√¢che.\n\n**Informations manquantes :**\n${missingFields.map(f => `‚Ä¢ ${f}`).join('\n')}\n\n**Questions pour clarifier :**\n${questions.map((q, i) => `${i + 1}. ${q}`).join('\n')}\n\nMerci de compl√©ter les champs manquants pour continuer.`;

          workflow.status = 'waiting_for_input';
          workflow.finalResult = interactiveMessage;

          // On ne retourne que l'√©tape de validation
          workflow.steps = workflow.steps.slice(0, 1);
          return interactiveMessage;
        }

        return `‚úÖ **Validation r√©ussie**\n\nToutes les informations requises sont pr√©sentes.\n\n**Prochaine √©tape :** Planification.`;
      });

      if (workflow.status === 'waiting_for_input') {
        // G√©n√©rer les questions √† partir de la config pour l'UI
        const configResponse = await this.configurationService.getByServiceId(serviceId);
        const config = configResponse.data;
        if (!config) throw new NotFoundException('Configuration du service introuvable');
        const inputSchema = config.inputSchema;
        const requiredFields: string[] = inputSchema.required || [];
        const properties = inputSchema.properties || {};
        const missingFields = requiredFields.filter(
          (key) => input[key] === undefined || input[key] === null || input[key] === ''
        );
        const questions = missingFields.map((key) => {
          const prop = properties[key] || {};
          const label = prop.title || prop.label || key;
          const desc = prop.description ? ` (${prop.description})` : '';
          return `Merci de renseigner : ${label}${desc}`;
        });
        // On ne retourne que l'√©tape de validation
        workflow.steps = workflow.steps.slice(0, 1);
        return {
          success: true,
          workflow,
          data: {
            result: workflow.finalResult,
            requiresMoreInput: true,
            missingInfo: missingFields,
            questions
          }
        };
      }

      // Si la validation est OK, on ajoute les √©tapes suivantes au workflow
      const planningStep: WorkflowStep = {
        id: 'planning',
        name: 'Planification',
        description: '√âlaboration du plan d\'ex√©cution',
        status: 'pending'
      };
      const processingStep: WorkflowStep = {
        id: 'processing',
        name: 'Traitement',
        description: 'Ex√©cution du traitement principal',
        status: 'pending'
      };
      const finalizationStep: WorkflowStep = {
        id: 'finalization',
        name: 'Finalisation',
        description: 'Pr√©paration du r√©sultat final',
        status: 'pending'
      };
      workflow.steps.push(planningStep, processingStep, finalizationStep);

      // √âtape 2: Planification
      await this.executeStep(workflow, 1, async () => {
        const planningPrompt = `Tu es un expert en planification de t√¢ches.\n\nT√ÇCHE: Cr√©er un plan d√©taill√© pour ex√©cuter "${serviceName}".\n\nCONTEXTE: ${JSON.stringify(input, null, 2)}\n\nINSTRUCTIONS:\n1. Analyse la t√¢che √† accomplir\n2. D√©compose-la en sous-√©tapes logiques\n3. Identifie les ressources et m√©thodes n√©cessaires\n4. Cr√©e un plan d'ex√©cution clair\n\nR√©ponds au format JSON:\n{\n  "plan": ["√©tape 1", "√©tape 2", "√©tape 3"],\n  "methodology": "m√©thode d'ex√©cution",\n  "estimatedTime": "estimation du temps",\n  "risks": ["risques potentiels"]\n}`;

        const schema = {
          type: "object",
          properties: {
            plan: { type: "array", items: { type: "string" } },
            methodology: { type: "string" },
            estimatedTime: { type: "string" },
            risks: { type: "array", items: { type: "string" } }
          },
          required: ["plan", "methodology", "estimatedTime", "risks"]
        };

        const response = await this.ai.generate(
          systemPrompt,
          planningPrompt,
          schema,
          { stream: false, provider }
        );

        if (response.error) {
          throw new Error(`Erreur de planification: ${response.error}`);
        }

        const planning = response.result;
        
        return `üìã **Plan cr√©√©**\n\n${planning.plan.map((step, i) => `${i + 1}. ${step}`).join('\n')}\n\n**M√©thode :** ${planning.methodology}\n**Temps estim√© :** ${planning.estimatedTime}`;
      });

      // √âtape 3: Traitement principal
      await this.executeStep(workflow, 2, async () => {
        const processingPrompt = `Tu es maintenant en phase d'ex√©cution de la t√¢che "${serviceName}".\n\nEX√âCUTE la t√¢che en utilisant les entr√©es fournies et le plan √©tabli.\n\nENTR√âES: ${JSON.stringify(input, null, 2)}\n\nINSTRUCTIONS:\n1. Applique la m√©thodologie d√©finie\n2. Traite les donn√©es selon les sp√©cifications\n3. Assure-toi de la qualit√© du r√©sultat\n4. Documente le processus d'ex√©cution\n\nR√©ponds au format JSON:\n{\n  "result": "r√©sultat principal de l'ex√©cution",\n  "details": "d√©tails du processus",\n  "quality": "√©valuation de la qualit√©",\n  "notes": "notes importantes"\n}`;

        const schema = {
          type: "object",
          properties: {
            result: { type: "string" },
            details: { type: "string" },
            quality: { type: "string" },
            notes: { type: "string" }
          },
          required: ["result", "details", "quality", "notes"]
        };

        const response = await this.ai.generate(
          systemPrompt,
          processingPrompt,
          schema,
          { stream: false, provider }
        );

        if (response.error) {
          throw new Error(`Erreur de traitement: ${response.error}`);
        }

        const processing = response.result;
        
        return `‚öôÔ∏è **Traitement termin√©**\n\n**R√©sultat :** ${processing.result}\n\n**D√©tails :** ${processing.details}\n**Qualit√© :** ${processing.quality}`;
      });

      // √âtape 4: Finalisation
      await this.executeStep(workflow, 3, async () => {
        const finalizationPrompt = `Tu es en phase de finalisation de la t√¢che "${serviceName}".\n\nFINALISE le r√©sultat en le formatant de mani√®re professionnelle et utilisable.\n\nR√âSULTAT BRUT: ${workflow.steps[2].result}\n\nINSTRUCTIONS:\n1. Formate le r√©sultat final\n2. Ajoute des explications si n√©cessaire\n3. V√©rifie la coh√©rence\n4. Pr√©pare la livraison\n\nR√©ponds au format JSON:\n{\n  "finalResult": "r√©sultat final format√©",\n  "summary": "r√©sum√© de l'ex√©cution",\n  "recommendations": ["recommandations"],\n  "nextSteps": "prochaines √©tapes sugg√©r√©es"\n}`;

        const schema = {
          type: "object",
          properties: {
            finalResult: { type: "string" },
            summary: { type: "string" },
            recommendations: { type: "array", items: { type: "string" } },
            nextSteps: { type: "string" }
          },
          required: ["finalResult", "summary", "recommendations", "nextSteps"]
        };

        const response = await this.ai.generate(
          systemPrompt,
          finalizationPrompt,
          schema,
          { stream: false }
        );

        if (response.error) {
          throw new Error(`Erreur de finalisation: ${response.error}`);
        }

        const finalization = response.result;
        
        workflow.finalResult = finalization.finalResult;
        
        return `‚úÖ **Finalisation termin√©e**\n\n**R√©sultat final :** ${finalization.finalResult}\n\n**R√©sum√© :** ${finalization.summary}`;
      });

      workflow.status = 'completed';
      
      return {
        success: true,
        workflow,
        data: { result: workflow.finalResult }
      };

    } catch (error) {
      workflow.status = 'failed';
      workflow.error = error.message;
      
      return {
        success: false,
        workflow,
        error: error.message
      };
    }
  }

  private async executeStep(
    workflow: WorkflowExecution, 
    stepIndex: number, 
    stepFunction: () => Promise<string>
  ): Promise<string> {
    const step = workflow.steps[stepIndex];
    
    try {
      step.status = 'running';
      step.startTime = new Date();
      workflow.currentStepIndex = stepIndex;

      const result = await stepFunction();
      
      step.status = 'completed';
      step.result = result;
      step.endTime = new Date();
      
      return result;
      
    } catch (error) {
      step.status = 'failed';
      step.error = error.message;
      step.endTime = new Date();
      throw error;
    }
  }
} 